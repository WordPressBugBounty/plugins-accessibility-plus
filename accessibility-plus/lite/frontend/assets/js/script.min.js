// Accessibility Frontend Fixes - Deobfuscated Version

// Module: Language and Direction Fixes
const langAndDirFixes = (() => {
  const config_lang_dir = window._wyA11yConfig?.fixes?.langDir || { status: false };
  if (!config_lang_dir.status) return;
  const htmlElement = document.querySelector("html");
  const currentLang = htmlElement.getAttribute("lang");
  const currentDir = htmlElement.getAttribute("dir");
  
  // Set language if different or missing
  if (config_lang_dir.language && (!currentLang || currentLang !== config_lang_dir.language)) {
    htmlElement.setAttribute("lang", config_lang_dir.language);
  }
  
  // Set direction if different or missing
  if (config_lang_dir.direction && (!currentDir || currentDir !== config_lang_dir.direction)) {
    htmlElement.setAttribute("dir", config_lang_dir.direction);
  }
})();

// Module: Meta Viewport Scalable Fixes
const metaViewportScalableFixes = (() => {
  const config_meta_viewport_scalable = window._wyA11yConfig?.fixes?.metaViewportScale || { status: false };
  
  if (!config_meta_viewport_scalable.status) return;

  // Get all viewport meta tags
  const viewportTags = document.querySelectorAll('meta[name="viewport"]');
  
  // Handle multiple viewport tags (invalid HTML but happens in practice)
  if (viewportTags.length > 1) {
    // Remove duplicates, keep first one
    for (let i = 1; i < viewportTags.length; i++) {
      viewportTags[i].remove();
    }
  }

  const existingViewport = viewportTags[0];

  // Check for scaling restrictions
  const hasScalingRestriction = (content) => {
    if (!content) return false;
    // Check user-scalable=no or user-scalable=0
    if (content.match(/user\-scalable\s*=\s*(no|0)\b/i)) return true;
    // Check maximum-scale=1.0 (prevents scaling)
    if (content.match(/maximum\-scale\s*=\s*1\.?0*\b/i)) return true;
    return false;
  };

  // Parse and fix viewport content - preserve valid settings, remove restrictions
  const fixViewportContent = (content) => {
    if (!content) return "width=device-width, initial-scale=1";
    
    const parts = content.split(',').map(p => p.trim());
    const validParts = parts.filter(p => {
      // Remove problematic parts that prevent scaling
      if (p.match(/user\-scalable\s*=\s*(no|0)\b/i)) return false;
      if (p.match(/maximum\-scale\s*=\s*1\.?0*\b/i)) return false;
      return true;
    });

    // Add required parts if missing
    if (!validParts.some(p => p.startsWith('width='))) {
      validParts.push('width=device-width');
    }
    if (!validParts.some(p => p.startsWith('initial-scale='))) {
      validParts.push('initial-scale=1');
    }

    return validParts.join(', ');
  };

  if (existingViewport) {
    const content = existingViewport.getAttribute('content') || '';
    
    // Only fix if there's a scaling restriction
    if (hasScalingRestriction(content)) {
      const fixedContent = fixViewportContent(content);
      existingViewport.setAttribute('content', fixedContent);
    }
  } else {
    // Create viewport meta tag if missing
    const newViewport = document.createElement("meta");
    newViewport.name = "viewport";
    newViewport.content = "width=device-width, initial-scale=1";
    document.head.appendChild(newViewport);
  }
})();

// Module: Prevent Links Opening New Windows
const preventLinksOpeningNewWindows = (() => {
  const config_prevent_links_opening_new_windows = window._wyA11yConfig?.fixes?.removeTargetBlank || { status: false };
  if (!config_prevent_links_opening_new_windows.status) return;
  document.querySelectorAll('a[target="_blank"]:not(.wya11y-allow-open-new-tab)').forEach(link => {
    if (!link.closest(".wya11y-allow-open-new-tab")) {
      link.removeAttribute("target");
      link.classList.add("wya11y-target-blank-removed");
    }
  });
})();

// Module: New Window Warning
const newWindowWarning = (() => {
  const config_new_window_warning = window._wyA11yConfig?.fixes?.addTargetBlankLabel || { status: false };
  if (!config_new_window_warning.status) return;
  const tooltipText = "opens in a new window";
  const icon = ' ↗️'; // Icon to indicate a new window

  const addIcon = (link) => {
      // Check if the link already has the icon
      if (!link.querySelector('.wya11y-nww-external-link-icon')) {
          link.insertAdjacentHTML('beforeend', `<span class="wya11y-nww-external-link-icon" aria-hidden="true">${icon}</span>`);
          // Update aria-label to indicate it opens in a new window
          link.setAttribute('aria-label', `${link.getAttribute('aria-label') || ''} ${tooltipText}`);
      }
  };

  const processLinks = () => {
      // Process unprocessed links
      document.querySelectorAll("a[target='_blank']").forEach(link => {
          // Add the class and icon if the option is enabled
          link.classList.add('wya11y-allow-open-new-tab');
          addIcon(link);
      });
  };

  // Execute the function to process links
  processLinks();
})();

// Module: Remove Title If Preferred Accessible Name
const removeTitleIfPreferredAccessibleName = (() => {
  const config_remove_title_if_preferred_accessible_name = window._wyA11yConfig?.fixes?.removeTitleIfAccessibleName || { status: false };
  if (!config_remove_title_if_preferred_accessible_name.status) return;
  const handleImage = (element) => {
    const altText = element.getAttribute("alt");
    const titleValue = element.getAttribute("title");
    
    // If alt is missing/empty
    if (!altText || altText.trim() === "") {
      // If title exists (even if empty), use it to update alt
      if (titleValue !== null && titleValue !== undefined) {
        element.setAttribute("alt", titleValue.trim() || "");
      }
    }
    // Always remove title (whether we used it or not)
    removeTitle(element);
  };
  
  const handleInteractiveElement = (element) => {
    const innerText = element.innerText;
    const titleValue = element.getAttribute("title");
    
    // If no visible text AND no accessible name
    if (!innerText || innerText.trim() === "") {
      if (!hasAccessibleName(element)) {
        // If title exists (even if empty), use it to update aria-label
        if (titleValue !== null && titleValue !== undefined) {
          element.setAttribute("aria-label", titleValue.trim() || "");
        }
      }
    }
    removeTitle(element);
  };
  
  const handleFormElement = (element) => {
    if (hasAccessibleName(element)) {
      removeTitle(element);
      return;
    }
    
    const labelText = element.labels?.[0]?.innerText;
    const closestLabelText = element.closest("label")?.innerText;
    const titleValue = element.getAttribute("title");
    
    // If no label
    if ((!labelText || labelText.trim() === "") && (!closestLabelText || closestLabelText.trim() === "")) {
      // If title exists (even if empty), use it to update aria-label
      if (titleValue !== null && titleValue !== undefined) {
        element.setAttribute("aria-label", titleValue.trim() || "");
      }
    }
    removeTitle(element);
  };
  
  const removeTitle = (element) => {
    element.classList.add("wya11y-title-removed");
    element.removeAttribute("title");
  };
  
  const hasAccessibleName = (element) => {
    const ariaLabel = element.getAttribute("aria-label");
    const ariaLabelledby = element.getAttribute("aria-labelledby");
    return !!(ariaLabel && ariaLabel.trim() !== "") || !!(ariaLabelledby && ariaLabelledby.trim() !== "");
  };
  
  document.querySelectorAll("img[title], a[title], input[title], textarea[title], select[title], button[title]").forEach(element => {
    const titleValue = element.getAttribute("title");
    
    // Skip if no title attribute
    if (titleValue === null || titleValue === undefined) {
      return;
    }
    
    // Handle aria-hidden elements: just remove title, don't update accessible name
    if (element.getAttribute("aria-hidden") === "true") {
      removeTitle(element);
      return;
    }
    
    const tagName = element.tagName.toLowerCase();
    if (tagName === "img") {
      handleImage(element);
    } else if (["a", "button"].includes(tagName)) {
      handleInteractiveElement(element);
    } else if (["input", "textarea", "select"].includes(tagName)) {
      handleFormElement(element);
    }
  });
})();

// Module: Skip Link
const skipLink = (() => {
  const config_skip_link = window._wyA11yConfig?.fixes?.enableSkipLink || { status: false };
  if (!config_skip_link.status) return;
  const template = document.getElementById("wya11y-skip-link-template");
  if (!template) return;

  if (!window._wyA11yConfig?.fixes?.enableSkipLink?.targets) return;
  // Check if there's already a skip link
  const hasExistingSkipLink = (() => {
    // WordPress theme-provided skip link
    const themeSkipLink = document.querySelector('a#wp-skip-link.skip-link[href="#wp--skip-link--target"]:not(.ab-item)')
      || document.querySelector('a.skip-link[href^="#"]:not(.ab-item)');
    if (themeSkipLink) {
      const href = themeSkipLink.getAttribute('href');
      if (href && href.startsWith('#')) {
        const targetId = href.slice(1).trim();
        if (!targetId) return false;
        return !!document.getElementById(targetId);
      }
    }
    return false;
  })();
  if (hasExistingSkipLink) { template.remove(); return; }
  const targets = window._wyA11yConfig.fixes.enableSkipLink.targets;
  const targetsArray = targets.split(",");
  const targetsArrayWithHash = targetsArray.map(target => target.startsWith("#") ? target : `#${target}`);
  
  let target = false;
  let targetId = false;
  for (const selector of targetsArrayWithHash) {
      const element = document.querySelector(selector);
      if (element) {
          target = element; // Assign the first found element to target
          targetId = selector;
          break; // Exit the loop once the first element is found
      }
  }
  const skipLinkNode = template.content.cloneNode(true);
  
  if (targetId) {
    skipLinkNode.querySelector(".wya11y-skip-link-content").href = targetId;
    
    // Make target focusable and add click handler
    const targetElement = document.querySelector(targetId);
    if (targetElement) {
      if (targetElement.tabIndex === -1) {
        targetElement.setAttribute("tabindex", "0");
      }
      
      skipLinkNode.querySelector(".wya11y-skip-link-content")?.addEventListener("click", () => {
        try {
          history.pushState({}, "", targetId);
        } catch (error) {
          console.error("Error updating history for skip link.");
        }
        targetElement.focus();
      }, { once: true });
    }
  } else {
    skipLinkNode.querySelector(".wya11y-skip-link-content").remove();
  }
  
  document.body.prepend(skipLinkNode);
})();

// Module: Observe Theme Skip Link and Remove Plugin Skip Link
const observeThemeSkipLink = (() => {
  const config_skip_link = window._wyA11yConfig?.fixes?.enableSkipLink || { status: false };
  if (!config_skip_link.status) return;

  const hasValidThemeSkipLink = () => {
    const themeSkipLink = document.querySelector('a#wp-skip-link.skip-link[href="#wp--skip-link--target"]:not(.ab-item)')
      || document.querySelector('a.skip-link[href^="#"]:not(.ab-item)');
    if (!themeSkipLink) return false;
    const href = themeSkipLink.getAttribute('href');
    if (!href || !href.startsWith('#')) return false;
    const targetId = href.slice(1).trim();
    if (!targetId) return false;
    return !!document.getElementById(targetId);
  };

  const removePluginSkipLinks = () => {
    document.querySelectorAll('a.wya11y-skip-link-content').forEach(link => {
      const parent = link.parentElement;
      link.remove();
      if (parent && parent.childElementCount === 0 && parent.textContent.trim() === '') {
        parent.remove();
      }
    });
  };

  if (hasValidThemeSkipLink()) {
    removePluginSkipLinks();
    return;
  }

  const observer = new MutationObserver(() => {
    if (hasValidThemeSkipLink()) {
      removePluginSkipLinks();
      observer.disconnect();
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });
})();

// Module: Tab Index Fixes
const tabIndexFixes = (() => {
  const config_tab_index_fixes = window._wyA11yConfig?.fixes?.removeTabIndex || { status: false };
  if (!config_tab_index_fixes.status) return;
  // Fix existing tabindex attributes
  document.querySelectorAll("[tabindex]").forEach(element => {
    if (element.tagName === "A" && (!element.hasAttribute("href") || element.getAttribute("role") === "button")) {
      element.setAttribute("tabindex", "0");
    } else if (element.getAttribute("tabindex") !== "-1" && element.getAttribute("tabindex") > 0) {
      element.setAttribute("tabindex", "0");
      element.classList.add("wya11y-modified-focusable");
    }
  });
  
  // Add tabindex to button roles without it
  document.querySelectorAll('div[role="button"]:not([tabindex]), a[role="button"]:not([tabindex]):not([href])').forEach(element => {
    if (!element.hasAttribute("tabindex") || element.getAttribute("tabindex") !== "-1") {
      element.setAttribute("tabindex", "0");
      element.classList.add("wya11y-focusable-added");
    }
  });
})();

// Module: Underline Links
const underlineLinks = (() => {
  const config_underline_links = window._wyA11yConfig?.fixes?.forceUnderlineOnLinks || { status: false };
  if (!config_underline_links.status) return;
  document.querySelectorAll(config_underline_links.target).forEach(function(link) {
    // Skip links in navigation
    if (link.closest("nav") || link.closest('[role="navigation"]')) {
      return;
    }
    // Apply underline styling
    link.style.textDecoration = "underline";
    
    // Store original outline properties
    link.setAttribute("data-original-outline", link.style.outlineWidth);
    link.setAttribute("data-original-offset", link.style.outlineOffset);
    link.setAttribute("data-original-color", link.style.outlineColor);
    
    const linkColor = link.style.color;
    
    // Mouse events
    link.addEventListener("mouseenter", function() {
      link.style.textDecoration = "none";
    });
    
    link.addEventListener("mouseleave", function() {
      link.style.textDecoration = "underline";
    });
    
    // Focus events
    link.addEventListener("focusin", function() {
      let outlineWidth = "2px";
      if (link.style.outlineWidth === "2px") {
        outlineWidth = "4px";
      }
      link.style.outlineWidth = outlineWidth;
      link.style.outlineColor = linkColor;
      link.style.outlineOffset = "2px";
    });
    
    link.addEventListener("focusout", function() {
      link.style.outlineWidth = link.getAttribute("data-original-outline");
      link.style.outlineColor = link.getAttribute("data-original-color");
      link.style.outlineOffset = link.getAttribute("data-original-offset");
    });
  });
})();
